# 为什么我的MySQL会“抖”一下？
### 现象
一条SQL语句，正常执行的时候特别快，但有时会变得特别慢，并且场景难以复现，不止随机，而且持续时间很短。看上去，就像数据库“抖”了一下。

### WAL机制
InnoDB在处理更新语句的时候，只做了写日志这一磁盘操作。这个日志叫做redo log(重做日志)。

在更新内存写完redo log后，就返回给客户端，本次更新成功。

### flush
把内存的数据写入磁盘的过程，就是 flush。

### 脏页/干净页
当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为”脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为”干净页“。

### 数据更新过程(WAL机制)
更新内存页 + 写redolog 然后返回给客户端

### 数据flush过程
内存数据页写入磁盘，redolog   point 往前移

### “抖”一下的原因
平时执行很快的更新操作，是在写内存和日志，偶尔”抖“一下的瞬间，可能是在刷脏页(flush)。

### 引发数据库flush的情况
1. InnoDB的 redo log 写满了

这时候系统会停止所有的更新操作，把check point 往前推进，redo log 留出空间可以继续写。(check point) (write pos)

check point 的位置往前推进，需要将两个点之间的日志，对应的所有脏页都flush到磁盘上。之后，从write pos 到 check point 之间就是可以再写入的 redo log 的区域。

2. 系统内存不足

当需要新的内存页，而内存页不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是脏页，就要先将脏页写到磁盘。

* 淘汰脏页的时候为什么要写磁盘(而非直接淘汰，下次请求的时候，从磁盘读入数据页，然后拿redo log出来应用)

是从性能方面的考虑，每次刷脏页的时候写盘，保证了数据页有两种状态

1. 内存里存在，内存里就肯定是正确的结果，直接返回
2. 内存里没有数据，肯定数据文件是正确的结果，读入内存后返回
3. MySQL认为系统”空闲“的时候
4. Mysql正常关闭的情况

这时候MySQL会把内存的脏页都flush到磁盘上，这样MySQL下次启动的时候，就可以直接从磁盘上读数据。

#### 刷脏页的四种情况对性能的影响
第三种情况属于MySQL空闲时的操作，这时系统没什么压力。

第四种场景是数据库本来就要关闭了。

这两种场景不需要关注性能问题。

##### 需要关注性能的场景
1. redo log 写满，要flush脏页

这种情况要尽量避免。出现这种情况的时候，整个系统不能再接受更新，所有的更新都会堵住。(从监控上看，这时候的更新数跌为0)

2. 内存不够用了，要先将脏页写到磁盘，这种情况是常态

* InnoDB用缓冲池(buffer pool)管理内存，缓冲池中的内存页有三种状态：

1. 还没有使用的
2. 使用了并且是干净页
3. 使用了并且是脏页
* InnoDB的策略是尽量使用内存

对于一个长时间运行的库来说，未被使用的页面很少

当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页

这时候只能把最久不使用的数据页从内存中淘汰掉

如果要淘汰一个干净页，就直接释放出来复用

如果是脏页，必须将脏页先刷到磁盘，变成干净页后才能服用
###### 刷脏页是常态，以下两种情况会明显影响性能

1. 一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长
2. 日志写满，更新全部堵住，写性能跌为0，这种情况对敏感业务来说，是不能接受的

InnoDB必须有控制脏页比例的机制，来尽量避免上面的这两种情况

##### InnoDB刷脏页的控制策略
告诉InnoDB，所在主机的IO能力，这样InnoDB才知道需要全力刷脏页的时候，可以刷多快

告诉InnoDB磁盘能力，参数： innodb\_io\_capacity

该值建议设置成磁盘的IOPS

磁盘的IOPS可以用fio工具来测试

测试磁盘随机读写

```bash
 fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest 
```
InnoDB如何控制引擎按照“全力”的百分比来刷脏页

参数 innodb-max\_dirty\_pages\_pct 是脏页比例上限，默认是75%

InnoDB会根据当前的脏页比例(假设为M)，算出一个范围在0-100之间的数字

计算这个数字的代码类似如下

```bash
F1(M)
{
  if M>=innodb_max_dirty_pages_pct then
      return 100;
  return 100*M/innodb_max_dirty_pages_pct;
}
```
InnoDB每次写入的日志都有一个序号，当前写入的序号跟 checkpoint对应的序号之间的差值，我们假设为N。InnoDB会根据这个N算出一个范围在0-100之间的数字，这个计算公式可以记为F2(N)。F2(N)算法比较复杂，这里先理解值越大越好。

根据上述算得的F1(M)和F2(N)两个值，取其中较大的值记为R，之后引擎就可以按照 innodb\_io\_capacity定义的能力乘以R%来控制刷脏页的速度。

InnoDB会在后台刷脏页，刷脏页的过程是将内存页写入磁盘。

* “抖”一下的原因
  * 查询语句在需要内存的时候可能要求淘汰一个脏页
  * 刷脏页的逻辑占用IO资源并可能影响到更新语句

要避免这种情况，要合理地设置 innodb\_io\_capacity 的值，并且平时要多关注脏页比例，不要让他经常接近75%

脏页比例是通过 Innodb\_buffer\_pool\_pages\_dirty/Innodb\_buffer\_pool\_pages\_total 得到的，具体命令如下

```sql
mysql> select VARIABLE_VALUE into @a from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty';
select VARIABLE_VALUE into @b from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_total';
select @a/@b;
```
##### 刷脏页的"连坐"机制
Mysql中的一个机制，可能让查询更慢。

在准备刷脏页的时候，如果这个数据页旁边的数据页刚好是脏页，就会把这个“邻居”也带着一起刷掉。而且把这个“邻居”拖下水的逻辑还可以继续蔓延。也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷。

参数 innodb\_flush\_neighbors 用来控制这个行为，值为“1”的时候会有上述的“连坐”机制。值为0时表示不找邻居，自己刷自己的。

这个机制在机械硬盘时代有意义，可以减少很多随机IO。

机械硬盘的随机IOPS一般只有几百，相同的逻辑操作减少随机IO就意味着系统性能的大幅度提升。

使用SSD，建议将该参数设置为0。这时候IOPS不是瓶颈，只刷自己，能更快的执行完必要的刷脏页操作，减少SQL语句响应时间。

在Mysql 8.0中，innodb\_flush\_neighbors 参数的默认值是0

### 解决问题
通过参数配置控制刷脏页的速度(磁盘IO能力\[innodb\_io\_capacity\],脏页比例上限\[innodb\_max\_dirty\_pages\_pct\],“连坐”机制\[innodb\_flush\_neighbors\])，来保证MySQL运行稳定，避免数据库“抖”一下

### 总结
InnoDB的SQL更新机制(WAL)决定了脏页的存在，在redlog写满或者内存不够，淘汰数据页的时候，需要刷脏页。这两种情况下MySQL的性能会受到影响。可以通过配置主机磁盘IO能力、脏页比例上限、连坐机制来控制MySQL刷脏页的速度与策略，避免MySQL不稳定。

* 类比记忆
  * 内存数据页 = 掌柜内存
  * redolog  = 记录用的粉板
  * 磁盘 = 账本