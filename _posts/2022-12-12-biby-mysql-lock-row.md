# \*\_\* 行锁功过：怎么减少行锁对性能的影响？
# 行锁
MySQL行锁由引擎层实现。

MyISAM引擎不支持行锁，InnoDB支持行锁。

合理的锁设计，减少锁冲突，提高业务并发度。

## 两阶段锁
在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这就是两阶段锁协议。

如果在事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。

## 死锁和死锁检测
当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程进入无限等待的状态，称为死锁。
### 出现死锁后的两种策略

1. 直接进入等待，直到超时。超时时间通过 innodb\_lock\_wait\_time 来设置。
2. 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb\_deadlock\_detect 设置为 on，标识开启这个逻辑。

在InnoDB中，innodb\_lock\_wait\_time默认是50s。这个等待时间难以接受，但是设置太小又有可能有误伤。正常情况下采用策略2。

* 衍生问题，cpu利用率很高（可能接近100%），但是每秒执行的事务没有几个。

  线程阻塞的时候主动死锁检测，如果对同一行有多个线程并发修改，假设1000个，那么死锁检测就是100万的量级。这种情况就会耗费打大量CPU资源。现象就是CPU利用率很高，但是每秒执行不了几个事务。

* 怎么解决热点行更新导致的性能问题
  * 问题症结是死锁检测耗费大量的CPU资源
1. 关闭死锁检测
  1. 	有风险，可能导致大量超时
2. 控制并发度
  1. 	对于相同行的更新，在进入引擎之前排队
3. 从设计上优化
  1. 	将一行改成逻辑上多行来减少锁冲突