# \*-\* 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？
# 锁
数据库锁设计的初衷是处理并发问题。

根据加锁的范围，Mysql里面的锁大致可以分为全局锁、表级锁和行锁三类。

## 全局锁
全局锁即对整个数据库实例加锁。

MySQL提供一个加全局读锁的方法：Flush tables with read lock(FTWTL)。当需要让整个库处于只读状态的时候可用该命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。

全局锁的典型使用场景是，做全库逻辑备份。

不加锁的话。备份系统备份得到的库不是一个逻辑时间点，这个视图是逻辑不一致的。

在可重复读隔离级别下开启一个事务，能够拿到一致性视图。

使用官方自带逻辑备份工具备份时，添加参数 -single-transaction，在导数据之前启动一个事务，来确保拿到一致性视图。由于mvcc的支持，这个过程中数据是可以正常更新的。

另一种全局只读的方式是 set global readonly=true，但需要全库只读时，建议使用FTWRL，原因如下

1. readonly可能被用来做其他逻辑，如判断一个库是主库还是备库。修改global变量的方式影响较大，不建议使用。
2. 处理机制上的差异。FTWRL如果碰到客户端异常断开，MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而设置为readonly，如果客户端发生异常，数据库会一直保持readonly状态，导致整个库处于长时间不可写状态，风险较高。

## 表级锁
MySQL有两种表级锁

1. 表锁
2. 元数据锁(meta data lock(MDL))

* 表锁

```bash
lock tables ... read/write
```
可以使用unlock tables主动释放锁，也可以在客户端断开时自动释放。

* MDL(meta data lock)

MDL不需要显示使用，在访问一个表的时候会被自动加上。

MDL的作用是保证读写的正确性。

当对一个表做增删改查操作的时候，加MDL读锁，当对表结构做变更操作的时候，加MDL写锁。

1. 读锁之间不互斥，可以有多个线程同时对一张表增删改查。
2. 读写锁之间，写锁之间是互斥的，用来保证变更表结构操作的安全性。如果有两个线程同时要给一个表加字段，其中一个要等另一个执行完才能开始执行。

### 给一个小表加字段
给一个表加字段、或者修改字段、或者加索引，需要扫描全表的数据。

事务中的MDL锁，在语句开始执行时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。

* 如何给小表安全的加字段
   1. 要解决长事务，事务不提交，就会一直站着MDL锁。在MySQL的information*schema库的innodb*trx表中，可以查看当前执行中的事务。如果要做DDL变更的表有长事务在执行，要先暂停DDL或者kill掉这个长事务。
   2. 如果是个热点表，表数据量不大，但是请求频繁。热点表kill不一定有用，因为新的请求码商到来。可以在alter table 语句里面设置等待时间，如果在指定时间能够拿到MDL写锁，则执行变更，拿不到则不阻塞后面业务语句，先放弃，后面再重试该过程。

```bash
ALTER TABLE tbl_name NOWAIT add column ...
ALTER TABLE tbl_name WAIT N add column ...
```
